name: RISC-16 Processor CI/CD

on:
  push:
    branches: [ main, develop ]
  pull_request:
    branches: [ main ]

jobs:
  lint-and-verify:
    runs-on: ubuntu-latest
    
    steps:
    - name: Checkout code
      uses: actions/checkout@v4
      
    - name: Setup Verilator
      run: |
        sudo apt-get update
        sudo apt-get install -y verilator
        
    - name: Setup Python for testing
      uses: actions/setup-python@v4
      with:
        python-version: '3.9'
        
    - name: Install Python dependencies
      run: |
        pip install cocotb pytest cocotb-test
        
    - name: Verilator Lint Check
      run: |
        # Lint individual modules
        verilator --lint-only --Wall -Wno-UNUSEDSIGNAL -Wno-PINCONNECTEMPTY \
          --top-module alu alu.sv
        verilator --lint-only --Wall -Wno-UNUSEDSIGNAL -Wno-PINCONNECTEMPTY \
          --top-module control control.sv
        verilator --lint-only --Wall -Wno-UNUSEDSIGNAL -Wno-PINCONNECTEMPTY \
          --top-module regfile regfile.sv
        verilator --lint-only --Wall -Wno-UNUSEDSIGNAL -Wno-PINCONNECTEMPTY \
          --top-module pc pc.sv
        verilator --lint-only --Wall -Wno-UNUSEDSIGNAL -Wno-PINCONNECTEMPTY \
          --top-module data_memory data_memory.sv
        verilator --lint-only --Wall -Wno-UNUSEDSIGNAL -Wno-PINCONNECTEMPTY \
          --top-module instr_memory instr_memory.sv
        
    - name: Create test program
      run: |
        # Create a simple test program for instruction memory
        cat > program.mem << 'EOF'
        0000000000000000
        0001000001000000
        0010000010000001
        0100000011000001
        0110000000000010
        0000000000000000
        EOF
        
    - name: Verilator Compilation Test
      run: |
        # Test compilation of top-level module
        verilator --cc --exe --build -Wall -Wno-UNUSEDSIGNAL -Wno-PINCONNECTEMPTY \
          --top-module risc16_top risc16_top.sv --exe-name risc16_sim
          
    - name: Create basic testbench
      run: |
        cat > test_risc16.cpp << 'EOF'
        #include "Vrisc16_top.h"
        #include "verilated.h"
        #include <iostream>
        
        int main(int argc, char** argv) {
            Verilated::commandArgs(argc, argv);
            Vrisc16_top* top = new Vrisc16_top;
            
            // Reset
            top->reset = 1;
            top->clk = 0;
            top->eval();
            top->clk = 1;
            top->eval();
            top->reset = 0;
            
            // Run for a few clock cycles
            for (int i = 0; i < 10; i++) {
                top->clk = 0;
                top->eval();
                top->clk = 1;
                top->eval();
                std::cout << "Cycle " << i << ": PC = 0x" << std::hex << top->curr_pc 
                         << ", Instr = 0x" << top->curr_instr << std::endl;
            }
            
            delete top;
            return 0;
        }
        EOF
        
    - name: Build and run basic simulation
      run: |
        verilator --cc --exe --build -Wall -Wno-UNUSEDSIGNAL -Wno-PINCONNECTEMPTY \
          --top-module risc16_top risc16_top.sv test_risc16.cpp --exe-name risc16_sim
        ./obj_dir/risc16_sim

  unit-tests:
    runs-on: ubuntu-latest
    needs: lint-and-verify
    
    steps:
    - name: Checkout code
      uses: actions/checkout@v4
      
    - name: Setup Verilator
      run: |
        sudo apt-get update
        sudo apt-get install -y verilator
        
    - name: Setup Python and CocoTB
      uses: actions/setup-python@v4
      with:
        python-version: '3.9'
        
    - name: Install test dependencies
      run: |
        pip install cocotb pytest cocotb-test
        
    - name: Create ALU unit test
      run: |
        mkdir -p tests
        cat > tests/test_alu.py << 'EOF'
        import cocotb
        from cocotb.clock import Clock
        from cocotb.triggers import RisingEdge
        
        @cocotb.test()
        async def test_alu_add(dut):
            """Test ALU addition operation"""
            dut.alu_src1.value = 0x1234
            dut.alu_src2.value = 0x5678
            dut.ADD.value = 1
            dut.NAND.value = 0
            dut.PASS1.value = 0
            dut.EQ.value = 0
            
            await cocotb.triggers.Timer(1, units='ns')
            
            expected = (0x1234 + 0x5678) & 0xFFFF
            assert dut.alu_out.value == expected, f"ADD failed: got {dut.alu_out.value:04x}, expected {expected:04x}"
            
        @cocotb.test()
        async def test_alu_nand(dut):
            """Test ALU NAND operation"""
            dut.alu_src1.value = 0xF0F0
            dut.alu_src2.value = 0x0F0F
            dut.ADD.value = 0
            dut.NAND.value = 1
            dut.PASS1.value = 0
            dut.EQ.value = 0
            
            await cocotb.triggers.Timer(1, units='ns')
            
            expected = ~(0xF0F0 & 0x0F0F) & 0xFFFF
            assert dut.alu_out.value == expected, f"NAND failed: got {dut.alu_out.value:04x}, expected {expected:04x}"
        EOF
        
    - name: Create control unit test
      run: |
        cat > tests/test_control.py << 'EOF'
        import cocotb
        from cocotb.triggers import Timer
        
        @cocotb.test()
        async def test_control_add(dut):
            """Test control signals for ADD instruction"""
            dut.opcode.value = 0b000  # ADD opcode
            dut.eq_out.value = 0
            
            await Timer(1, units='ns')
            
            assert dut.ADD.value == 1, "ADD signal should be high for ADD instruction"
            assert dut.we_reg.value == 1, "we_reg should be high for ADD instruction"
            assert dut.NAND.value == 0, "NAND should be low for ADD instruction"
            
        @cocotb.test()
        async def test_control_beq(dut):
            """Test control signals for BEQ instruction"""
            dut.opcode.value = 0b011  # BEQ opcode
            dut.eq_out.value = 1
            
            await Timer(1, units='ns')
            
            assert dut.EQ.value == 1, "EQ signal should be high for BEQ instruction"
            assert dut.BR.value == 1, "BR should be high when eq_out is true"
        EOF
        
    - name: Run ALU tests
      run: |
        cd tests
        cocotb-config --libdir
        make -f $(cocotb-config --makefiles)/Makefile.sim \
          MODULE=test_alu TOPLEVEL=alu VERILOG_SOURCES=../alu.sv SIM=verilator
          
    - name: Run Control tests  
      run: |
        cd tests
        make -f $(cocotb-config --makefiles)/Makefile.sim \
          MODULE=test_control TOPLEVEL=control VERILOG_SOURCES=../control.sv SIM=verilator

  integration-test:
    runs-on: ubuntu-latest
    needs: unit-tests
    
    steps:
    - name: Checkout code
      uses: actions/checkout@v4
      
    - name: Setup Verilator
      run: |
        sudo apt-get update
        sudo apt-get install -y verilator gtkwave
        
    - name: Create comprehensive test program
      run: |
        cat > program.mem << 'EOF'
        0000000000100000
        0001000001000010
        0010001000000101
        0110000000000010
        0100001001000000
        1010001000000100
        0000000000000000
        EOF
        
    - name: Create integration testbench
      run: |
        cat > integration_test.cpp << 'EOF'
        #include "Vrisc16_top.h"
        #include "verilated.h"
        #include "verilated_vcd_c.h"
        #include <iostream>
        
        int main(int argc, char** argv) {
            Verilated::commandArgs(argc, argv);
            Vrisc16_top* top = new Vrisc16_top;
            
            Verilated::traceEverOn(true);
            VerilatedVcdC* tfp = new VerilatedVcdC;
            top->trace(tfp, 99);
            tfp->open("simulation.vcd");
            
            int cycle = 0;
            
            // Reset
            top->reset = 1;
            top->clk = 0;
            top->eval();
            tfp->dump(cycle++);
            
            top->clk = 1;
            top->eval();
            tfp->dump(cycle++);
            
            top->reset = 0;
            
            // Run simulation
            for (int i = 0; i < 50; i++) {
                top->clk = 0;
                top->eval();
                tfp->dump(cycle++);
                
                top->clk = 1;
                top->eval();
                tfp->dump(cycle++);
                
                std::cout << "Cycle " << i << ": PC = 0x" << std::hex << top->curr_pc 
                         << ", Instr = 0x" << top->curr_instr << std::endl;
            }
            
            tfp->close();
            delete top;
            return 0;
        }
        EOF
        
    - name: Build and run integration test
      run: |
        verilator --cc --exe --build --trace -Wall -Wno-UNUSEDSIGNAL -Wno-PINCONNECTEMPTY \
          --top-module risc16_top risc16_top.sv integration_test.cpp --exe-name integration_sim
        ./obj_dir/integration_sim
        
    - name: Upload simulation artifacts
      uses: actions/upload-artifact@v3
      if: always()
      with:
        name: simulation-results
        path: |
          simulation.vcd
          *.log
        retention-days: 7

  documentation:
    runs-on: ubuntu-latest
    if: github.ref == 'refs/heads/main'
    
    steps:
    - name: Checkout code
      uses: actions/checkout@v4
      
    - name: Generate documentation
      run: |
        mkdir -p docs
        cat > docs/README.md << 'EOF'
        # RISC-16 Processor Documentation
        
        ## Architecture Overview
        
        The RISC-16 is a 16-bit reduced instruction set processor with the following components:
        
        - **Program Counter (PC)**: 16-bit counter for instruction addressing
        - **Register File**: 8 registers, 16-bit each (R0 hardwired to zero)
        - **ALU**: Supports ADD, NAND, PASS1 operations and equality comparison
        - **Instruction Memory**: 256 x 16-bit read-only memory
        - **Data Memory**: 256 x 16-bit read/write memory
        - **Control Unit**: Decodes 3-bit opcodes and generates control signals
        
        ## Supported Instructions
        
        | Opcode | Instruction | Description |
        |--------|-------------|-------------|
        | 000    | ADD         | Add two registers |
        | 001    | NAND        | NAND two registers |
        | 010    | LUI/JALR    | Load upper immediate / Jump and link register |
        | 011    | BEQ         | Branch if equal |
        | 100    | SW          | Store word |
        | 101    | LW          | Load word |
        
        ## Testing
        
        The processor includes comprehensive testing with:
        - Unit tests for individual modules
        - Integration tests for full processor
        - Linting and code quality checks
        
        EOF
        
    - name: Deploy documentation
      uses: actions/upload-artifact@v3
      with:
        name: documentation
        path: docs/